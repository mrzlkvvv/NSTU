
### Что такое API? На какие категории подразделяется Linux API?

**API** — набор правил и инструментов для взаимодействия с операционной системой.

**Категории Linux API:**
- Системные вызовы (syscalls) — низкоуровневые функции ядра (например, open, read, write).
- Библиотечные функции POSIX — стандартные обёртки над системными вызовами (например, fopen, fread из glibc).
- Специфичные API — например, для работы с сетью (socket), процессами (fork, exec), или файловыми системами (stat).

### Перечислите принципы, лежащие в основе Linux API

- **«Всё есть файл»** — устройства, сокеты, процессы представлены как файлы.
- **Композиция** — комбинирование маленьких утилит (например, `grep | sort | uniq`).
- **Открытость** — API стандартизирован через POSIX.

### Перечислите преимущества и недостатки реализации файловых операций средствами стандартной библиотеки С и системными вызовами Linux

**Преимущества стандартной библиотеки С:**
* Буферизация
* Переносимость
* Простота использования

**Преимущества системных вызовов Linux:**
* Больший контроль
* Отсутствие накладных расходов на буферизацию

### Перечислите режимы доступа и совместного использования файла в функции `open()`

- **Режимы доступа:**
    - `O_RDONLY` — только чтение.
    - `O_WRONLY` — только запись.
    - `O_RDWR` — чтение и запись.
    
- **Флаги совместного использования:**
    - `O_CREAT` — создать файл, если не существует.
    - `O_EXCL` — вернуть ошибку, если файл уже существует (требует `O_CREAT`).
    - `O_APPEND` — добавлять данные в конец файла.
    - `O_TRUNC` — очистить файл при открытии.

* В Linux API блокировки реализуются через `fcntl()` или `flock()`.

### Перечислите возможные атрибуты и флаги файла в функции `open()`

**Атрибуты (права доступа):**  
* R (W,X - по аналогии) для  пользователя, группы, остальных:
	   `S_IRUSR`, `S_IRGRP`, `S_IROTH`
* Одновременный RWX для пользователя, группы, остальных:
	   `S_IRWXU`, `S_IRWXG`, `S_IRWXO`

**Флаги:**
    - `O_NONBLOCK` — неблокирующий режим.
    - `O_SYNC` — синхронная запись (ожидание завершения операции).
    - `O_DIRECT` — прямой доступ к диску (минуя кэш ядра).

### Каковы особенности закрытия файла функцией `close()`?

```C
int inputHandle = open(filename, O_RDONLY);
  if (inputHandle < 0) {
    printf(
	    "Error %d (%s) while open file: %s\n",
	    errno, strerror(errno), filename
    );
    exit(-20);
  }
  
  
```

- Возвращает `0` при успехе, `-1` при ошибке (проверяйте через `errno`).
- **Важно:** Нельзя использовать дескриптор после `close()`.
- **Риск утечки ресурсов:** Если не закрыть файл, дескриптор останется занятым до завершения процесса.

